# -*- coding: utf-8 -*-
"""clf_Risk_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IGL3iahJaKYwnkAFJs14l0m-ADGeg6IC
"""

pip install pycaret

import os
from google.cloud import  bigquery
import pandas as pd

# Replace with the actual path to your JSON key file
credentials_path = "/content/caixa-bank-6c4f815e89ac.json"

# Check if the file exists
if not os.path.exists(credentials_path):
    raise FileNotFoundError(f"Credentials file not found: {credentials_path}")

# Set the environment variable
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = credentials_path

# **Important**: Restart the kernel or runtime environment after setting the environment variable.
# This ensures that the changes are picked up by the BigQuery client library.
client = bigquery.Client()

# getting client data
query = """ SELECT * FROM `caixa-bank.ML.risk_table`"""
risk_df = client.query(query).to_dataframe()

# getting transaction data
query = """ SELECT * FROM `caixa-bank.MAIN.transa_fraud_mcc`"""
transaction_df = client.query(query).to_dataframe()

#formatting and joining
risk_df.rename(columns={'customer_id':'client_id'}, inplace=True)
df_data= pd.merge(risk_df, transaction_df, how='left', on='client_id')


#removing unused colums
df_data.pop('fraud_count')
df_data.pop('mcc')
df_data.pop('id')
df_data.pop('date')
df_data.pop('use_chip')
df_data.pop('zip')
df_data.pop('online')
df_data.pop('merchant')
df_data.pop('merchant_id')
df_data.pop('merchant_city')
df_data.pop('merchant_state')
df_data.pop('card_id')

# value formating
df_data['fraud'] = df_data['fraud'].map({True: 1, False: 0})
df_data.replace({'gender':'Male'}, 0, inplace=True)
df_data.replace({'gender':'Female'}, 1, inplace=True)

# creating aggregated data frame
aggregated_df = df_data.groupby('client_id').agg({
    'current_age': 'max',
    'yearly_income': 'max',
    'total_debt': 'max',
    'credit_score': 'max',
    'per_capita_income': 'max',
    'fraud': 'sum',
    'gender': 'max',
    'amount': 'sum',
    'num_credit_cards': 'max',
    'retirement_age': 'max'
}).reset_index()

#adding calcuations
aggregated_df['debt_to_income_ratio']    =  aggregated_df['total_debt'] / aggregated_df['yearly_income'] # Customers with higher debt-to-income ratios are generally riskier.
aggregated_df['credit_utilization']      =  aggregated_df['total_debt'] / (aggregated_df['num_credit_cards'] * aggregated_df['credit_score'])# Customers with higher utilization (close to 1 or more) are generally riskier.
aggregated_df['age_to_retirement_ratio'] =  (aggregated_df['retirement_age'] - aggregated_df['current_age']) / aggregated_df['retirement_age']#Younger customers may behave differently than those nearing retirement.
aggregated_df['has_fraud_history']       =   aggregated_df['fraud'].apply(lambda x: 1 if x > 0 else 0)
aggregated_df['debt_credit_interaction'] =   aggregated_df['total_debt'] * aggregated_df['credit_score']

#creating risk function
def calculate_risk_category(row):
    if row['fraud'] > 20:
        return 'High Risk'
    elif row['credit_score'] < 600 and row['total_debt'] > 50000:
        return 'High Risk'
    elif 1 <= row['fraud'] <= 20:
        return 'Medium Risk'
    elif 600 <= row['credit_score'] <= 750 and 20000 <= row['total_debt'] <= 50000:
        return 'Medium Risk'
    elif row['fraud'] == 0 and row['credit_score'] >= 750:
        return 'Low Risk'
    else:
        return 'Low Risk'

# adding risk collum
aggregated_df['risk_category'] = aggregated_df.apply(calculate_risk_category, axis=1)

#priting aggregated_df to check for ML
aggregated_df.head()

from sklearn.model_selection import train_test_split

# Define features and target
X = aggregated_df[[

  #exluding features with fraud values
      #'has_fraud_history',
      #'fraud',


      ##'client_id', ##
      'current_age',
      'yearly_income',
      'total_debt',
      'credit_score',
      'per_capita_income',
      'gender',
      'amount',
      'num_credit_cards',
      'retirement_age',
      'debt_to_income_ratio',
      'credit_utilization',
      'age_to_retirement_ratio',
      'debt_credit_interaction']]

y = aggregated_df['risk_category']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

from pycaret.classification import setup

xp = setup(aggregated_df,
           target = "risk_category",
          normalize = True,
           session_id = 42)

from pycaret.classification import compare_models

best_model = compare_models()

from sklearn.preprocessing import StandardScaler
import lightgbm as lgb
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

clf = lgb.LGBMClassifier()

clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.4f}')


print(classification_report(y_test, y_pred))

!pip install ipywidgets

## generating a not used client_id
import random
min_value = 2000
max_value = 3000
random_client_id = random.randint(min_value, max_value)

import ipywidgets as widgets
from IPython.display import display, clear_output
import numpy as np

# Function to predict customer risk category
def predict_customer_risk(change=None):
    # Collect input values
    current_age = int(age_box.value)
    yearly_income = float(income_box.value)
    total_debt = float(debt_box.value)
    credit_score = float(credit_score_box.value)
    per_capita_income = float(per_capita_income_box.value)

    amount = float(amount_box.value)
    num_credit_cards = int(num_credit_cards_box.value)
    retirement_age = int(retirement_age_box.value)
    credit_utilization = float(credit_utilization_box.value)
    debt_credit_interaction = float(debt_credit_interaction_box.value)
    gender = gender_dropdown.value

    # One-hot encode gender
    gender = 0 if gender == 'Male' else 0

    # Create input array
    customer_data = np.array([[
        current_age, yearly_income,
        total_debt,
        credit_score,
        per_capita_income,
        gender,
        amount,
        num_credit_cards,
        retirement_age,
        total_debt / yearly_income,  # debt_to_income_ratio
        credit_utilization,
        (65 - current_age) / 65,    # age_to_retirement_ratio
        debt_credit_interaction
        ]])


    # Scale the input data
    customer_data_scaled = scaler.transform(customer_data)

    # Predict risk category
    risk_prediction = clf.predict(customer_data_scaled)[0]
    risk_label = risk_prediction  # Assuming risk_prediction is in the right fromat

    # Display the result
    with output:
        clear_output(wait=True)
        print(f"Predicted Risk Category: {risk_label}")

# Input widgets
age_box = widgets.BoundedIntText(value=30, min=18, max=100, step=1, description='Age:')
income_box = widgets.FloatText(value=50000, description='Yearly Income:')
debt_box = widgets.FloatText(value=20000, description='Total Debt:')
credit_score_box = widgets.BoundedFloatText(value=700, min=300, max=850, step=1, description='Credit Score:')
per_capita_income_box = widgets.FloatText(value=20000, description='Per Capita Income:')
gender_dropdown = widgets.Dropdown(options=['Male', 'Female'], value='Male', description='Gender:')
amount_box = widgets.FloatText(value=20000, description='total amount spent:')
num_credit_cards_box = widgets.IntText(value=3, description='Number of Credit Cards:')
retirement_age_box = widgets.IntText(value=65, description='Retirement Age:')
credit_utilization_box = widgets.FloatText(value=0.5, description='Credit Utilization:')
debt_credit_interaction_box = widgets.FloatText(value=10000, description='Debt-Credit Interaction:')

# Submit button
submit_button = widgets.Button(description='Predict Risk')
submit_button.on_click(predict_customer_risk)

# Output area
output = widgets.Output()

# Display the widgets
input_widgets = widgets.VBox([
    age_box,
    income_box,
    debt_box,
    credit_score_box,
    per_capita_income_box,
    gender_dropdown,
    amount_box,
    num_credit_cards_box,
    retirement_age_box,
    credit_utilization_box,
    debt_credit_interaction_box,

    submit_button
    ])
display(input_widgets, output)

import joblib

# Save the trained model
joblib.dump(clf, 'clf.pkl')

# Save the scaler
joblib.dump(scaler, 'scaler.pkl')

print("Model and scaler saved successfully!")

# Load the model and scaler
model = joblib.load('clf.pkl')
scaler = joblib.load('scaler.pkl')

print("Model and scaler loaded successfully!")

from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Save files to Drive
joblib.dump(model, '/content/drive/My Drive/clf.pkl')
joblib.dump(scaler, '/content/drive/My Drive/scaler.pkl')

"""Done until here"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# from sklearn.preprocessing import StandardScaler
# from sklearn.linear_model import LogisticRegression
# import joblib
# 
# # Load the model and scaler
# model = joblib.load('clf.pkl')
# scaler = joblib.load('scaler.pkl')
# 
# st.title("Risk Prediction Application")
# 
# # Input fields
# age = st.slider("Current Age", 18, 100, 30)
# income = st.number_input("Yearly Income", min_value=0, value=50000)
# debt = st.number_input("Total Debt", min_value=0, value=20000)
# credit_score = st.slider("Credit Score", 300, 850, 700)
# per_capita_income = st.number_input("Per Capita Income", min_value=0, value=20000)
# gender = st.radio("Gender", ("Male", "Female"))
# 
# # Button to predict
# if st.button("Predict Risk"):
#     gender_values = [1, 0] if gender == "Male" else [0, 1]
#     input_data = [[age, income, debt, credit_score, per_capita_income] + gender_values]
#     scaled_data = scaler.transform(input_data)
#     prediction = model.predict(scaled_data)[0]
#     risk_category = ["Low Risk", "Medium Risk", "High Risk"][prediction]
#     st.success(f"The predicted risk category is: {risk_category}")
#

from pyngrok import ngrok

# Get your authtoken from https://dashboard.ngrok.com/auth
!ngrok authtoken <2pUqexxvlbJRzbF6qqsfo1rxNoI_4hegTWKWADwvtWMW4Tgqn> # Replace <YOUR_AUTHTOKEN> with your actual authtoken


#You can't directly run a Streamlit app within Colab. Instead, use a service like ngrok to expose your app to the internet.

!streamlit run app.py &

public_url = ngrok.connect(port="8501")
print(f"Streamlit app is live at: {public_url}")



